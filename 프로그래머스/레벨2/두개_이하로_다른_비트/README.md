# 2개 이하로 다른 비트

### 문제 설명

양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

- `x`보다 크고 `x`와 **비트가 1~2개 다른** 수들 중에서 제일 작은 수

예를 들어,

- `f(2) = 3` 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

| 수   | 비트         | 다른 비트의 개수 |
|-----|------------|-----------|
| 2   | 000...0010 |           |
| 3   | 000...0011 | 1         |

- `f(7) = 11` 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

| 수   | 비트         | 다른 비트의 개수 |
|-----|------------|-----------|
| 7   | 000...0111 |           |
| 8   | 000...1000 | 4         |
| 9   | 000...1001 | 3         |
| 10  | 000...1010 | 3         |
| 11  | 000...1011 | 2         |

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f` 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

-----------
### 제한 사항

- 1 ≤ `numbers`의 길이 ≤ 100,000
- 0 ≤ `numbers`의 모든 수 ≤ 10<sup>15</sup>

-----------
### 입출력 예

| numbers | result |
|---------|--------|
| [2,7]   | [3,11] |

-----------
### URL

https://programmers.co.kr/learn/courses/30/lessons/77885

-----------
## 풀이
1. 정답을 기록할 int형 배열 `answer`를 생성한다.
2. `numbers`를 순회하며 각 숫자 `number`에 대해 `f()`값을 구한다.
3. `number`가 짝수이면 마지막이 0이므로 1을 더한 값이 정답이된다.
4. 홀수이면 가장 나중에 나오는 0을 1로 바꾸고 그 뒤의 1중 가장 먼저 나오는 1을 0으로 바꾸면 정답이 된다.
   1. 가장 나중에 나오는 0을 구하는 함수를 `getLastZeroIndex()`로 정의한다.
   2. `getLastZeroIndex()`는 매개변수로 `number`를 받는다.
   3. `idx`를 0으로 시작하여 `number`를 2로 나누는 것을 반복한다.
   4. 나눈 나머지가 1이면 `idx`를 1올리고 반복한다.
   5. 나머지가 0이면 `idx`를 리턴한다.
   6. 이 `idx`의 바로 뒤가 가장 먼저나오는 1이다.
5. 모든 `number`에 대해 처리한 값을 `answer`에 저장했다면 리턴한다.