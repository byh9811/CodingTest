# 멀리 뛰기

### 문제 설명

이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. **초당 최대 처리량**은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.

-----------
### 입력 형식

- `solution` 함수에 전달되는 `lines` 배열은 N(1 ≦ **N** ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다.
- 응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 `2016-09-15 hh:mm:ss.sss` 형식으로 되어 있다.
- 처리시간 T는 `0.1s`, `0.312s`, `2s` 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 `s`로 끝난다.
- 예를 들어, 로그 문자열 `2016-09-15 03:10:33.020 0.011s`은 "2016년 9월 15일 오전 3시 10분 **33.010초**"부터 "2016년 9월 15일 오전 3시 10분 **33.020초**"까지 "**0.011초**" 동안 처리된 요청을 의미한다. **(처리시간은 시작시간과 끝시간을 포함)**
- 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 **0.001 ≦ T ≦ 3.000**이다.
- `lines` 배열은 응답완료시간 **S**를 기준으로 오름차순 정렬되어 있다.

-----------
### 출력 형식

- `solution` 함수에서는 로그 데이터 `lines` 배열에 대해 초당 최대 처리량을 리턴한다.

-----------
### 입출력 예

| lines                                                          | result |
|----------------------------------------------------------------|--------|
| ["2016-09-15 01:00:04.001 2.0s", "2016-09-15 01:00:07.000 2s"] | 1      |
| ["2016-09-15 01:00:04.002 2.0s", "2016-09-15 01:00:07.000 2s"] | 2      |

-----------
### URL

https://school.programmers.co.kr/learn/courses/30/lessons/17676

-----------
## 풀이
1. `lines`를 순회하며 문자열을 파싱하여 `startTime`과 `endTime`을 구해놓는다.
   1. 공백을 기준으로 파싱하고 인덱스 0번은 항상 `2016-09-15`이므로 무시해도 된다.
   2. 인덱스 1번은 종료시점을 의미하므로 한번 더 `:`로 파싱한 뒤 각 단위를 밀리초로 환산하여 `endTime`에 저장한다.
   3. 인덱스 2번은 처리 시간을 의미하므로 마지막 고정문자 `s`를 제외하고 읽어 밀리초로 환산한 뒤 `endTime`에서 빼고 +1을 하여 `startTime`에 저장한다.
2. `lines`를 인덱스로 순회하며 각 `endTime`에 대하여 다음을 수행한다.
   1. 이미 `lines`는 `endTime`을 기준으로 정렬되어 있으므로, 다른 `line`의 `startTime`만 현재 `line`의 `endTime+1000`을 넘지 않는다면 현재 `line`과 같은 윈도우에 처리될 수 있다.
   2. 이를 이용해 현재 `line`보다 종료시점이 늦는 모든 `line`에 대하여 `startTime`을 검사하고 1번의 조건을 만족하는 `line`의 개수를 센다.
   3. 2번의 반복을 끝내고 조건을 만족하는 `line`의 개수가 가장 큰 `line` 수를 기록하는 `max`보다 크다면 갱신한다.
3. 모든 `line`에 대하여 2번의 반복이 종료되면 `max`를 리턴한다.