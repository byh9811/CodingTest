# 징검다리

### 문제 설명

출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다.
예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.

| 제거한 바위의 위치  | 각 바위 사이의 거리   | 거리의 최솟값 |
|-------------|---------------|---------|
| [21, 17]    | [2, 9, 3, 11] | 2       |
| [2, 21]     | [11, 3, 3, 8] | 3       |
| [2, 11]     | [14, 3, 4, 4] | 3       |
| [11, 21]    | [2, 12, 3, 8] | 2       |
| [2, 14]     | [11, 6, 4, 4] | 4       |

위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.

출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.

-----------
### 제한 사항

- 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.
- 바위는 1개 이상 50,000개 이하가 있습니다.
- n 은 1 이상 `바위의 개수` 이하입니다.

-----------
### 입출력 예

| distance | rocks               | n   | return |
|----------|---------------------|-----|--------|
| 25       | [2, 14, 11, 21, 17] | 2   | 4      |
-----------
### URL

https://programmers.co.kr/learn/courses/30/lessons/43236

-----------
## 풀이
1. distance가 10억 이하이고 관련하여 사칙연산이 일어나지 않으므로 int형으로 선언이 가능하다.
2. 바위의 최대 개수는 50000이기 때문에 조합을 이용하여 풀 수 없기 때문에 더 효율적인 알고리즘이 필요하다.
3. 문제에서는 바위의 개수에 초점이 맞춰져 있지만, 이분탐색으로 바위 사이의 길이의 최소값에 초점을 맞춰야 풀 수 있다.
4. left = 1, right = distance로 초기화하고 rocks를 오름차순으로 정렬하여 이분 탐색을 진행한다.
5. mid = (left+right) / 2로 초기화하여 바위 사이 거리의 최솟값을 표현한다.
6. 각 바위를 순회하면서 바위 사이의 거리가 mid이상이 되도록 할 때, 제거되는 돌의 수를 구한다.
7. 제거되는 바위의 수가 n을 초과하면 문제의 조건을 만족하지 못하므로 바위를 덜 제거하기 위해 사이의 거리를 줄여야 하므로 right를 땡긴다.
8. 제거되는 바위 수가 n이하이면 문제의 조건을 만족하므로 그때의 mid를 answer에 저장하고 더 큰 길이의 최솟값을 찾기 위해 left를 땡긴다.
9. 5~8번을 left가 right이하가 될 때까지 반복한 뒤 answer를 리턴한다.